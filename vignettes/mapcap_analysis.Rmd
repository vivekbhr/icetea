---
title: "Analysing MAPCap data using icetea"
author: 
- name: "Vivek Bhardwaj"
  affiliation: 
  - "Max Planck Institute of Immunobiology and Epigenetics, Stübeweg 51, 79108, Freiburg, Germany"
  - "Faculty of Biology, University of Freiburg, Schänzlestraße 1, 79104, Freiburg, Germany"
- name: "Thomas Manke"
  affiliation: 
  - "Max Planck Institute of Immunobiology and Epigenetics, Stübeweg 51, 79108, Freiburg, Germany"
  email: "manke@ie-freiburg.mpg.de"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Analysing MAPCap data using icetea}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Abstract
**ICETEA** can be used to analyse sequencing data generated from conventional as well as modern CAGE protocols.
Here we show the usability of ICETEA in analysis of MAPCap data.

**MAPCap** (Multiplexed Affinity Purification of Capped RNA) is a newly developed CAGE protocol that allows fast and 
accutate detection of transcription start sites and gene expression analysis of a set of multiplexed samples.

## Quick Start

Here we show a set of minimal steps for the processing of MAPCap data for the detection of TSS. Starting from the 
raw fastq files, we can either perform quality trimming using a standard program (eg. cutadapt/trimgalore) or simply 
begin the analysis by creating a `CapSet` object. The `CapSet` object takes raw/quality trimmed fastq file paths as input,
along with a simple dataframe (called `sampleInfo`) which contains demultiplexing barcodes as rownames and another column 
called `samples` which contain the corresponding sample names. The following steps creates the object, demultiplexes the fastq, maps them, filters them and detects the TSS.

```{r quickIntro, eval=FALSE}
# load the package 
library(icetea)

# provide demultiplexing barcodes and sample names
idxlist <- c("CAAGTG", "TTAGCC", "GTGGAA", "TGTGAG")
dir <- system.file("extdata", package="icetea")
# corresponding sample names
fnames <- c("embryo1", "embryo2", "embryo3", "embryo4")
## create CapSet object
cs <- newCapSet(expMethod = 'MAPCap',
                fastq_R1 = file.path(dir, 'mapcap_test_R1.fastq.gz'),
                fastq_R2 = file.path(dir, 'mapcap_test_R2.fastq.gz'),
                idxList = idxlist,
                sampleNames = fnames)

# demultiplex fastq and trim the barcodes
dir.create("splitting")
cs <- demultiplexFASTQ(cs, max_mismatch = 1, outdir = "splitting", nthreads = 10)

# map fastq
dir.create("mapping")
cs <- mapCaps(cs, subread_idx, outdir = "03_mapping", nthreads = 20, logfile = "mapping/subread_mapping.log")

# filter PCR duplicates
dir.create("removedup")
cs <- filterDuplicates(cs, outdir = "removedup")

# detect TSS
dir.create("tssCalling")
cs <- detectTSS(cs, groups = c("wt", "wt", "mut", "mut"), outfile_prefix = "tssCalling")
```



## Help and citations

### How to get help

ICETEA questions could be posted to the [Bioconductor support site](https://support.bioconductor.org), which serves as a searchable knowledge base of questions and answers.

Posting a question and tagging with “ICETEA” will automatically send an alert to the package authors to respond on the support site. See the first question in the list of Frequently Asked Questions (FAQ) for information about how to construct an informative post.


### How to cite ICETEA

Please cite ICETEA as follows:



## Detailed description of the above workflow

### Creating a CapSet object

The workflow begins by creating an object of class `CapSet` using the function `newCapSet`. This contains information about the experiment method (CAGE, RAMPAGE or MAPCap), along with fastq type (`single` or `paired` end) and the path of the fastq files. It also contains a sampleInfo dataframe.

The sampleInfo is a dataframe containing the demultiplexing barcodes as rownames and the corresponding samplenames within a column 
called `samples`.

With this information, create the CapSet object as follows.

```{r makeCS, eval=TRUE}
# provide demultiplexing barcodes and sample names
idxlist <- c("CAAGTG", "TTAGCC", "GTGGAA", "TGTGAG")
dir <- system.file("extdata", package="icetea")
# corresponding sample names
fnames <- c("embryo1", "embryo2", "embryo3", "embryo4")

## CapSet object from raw (multiplexed) fastq files
library(icetea)
cs <- newCapSet(expMethod = 'MAPCap',
                fastq_R1 = file.path(dir, 'mapcap_test_R1.fastq.gz'),
                fastq_R2 = file.path(dir, 'mapcap_test_R2.fastq.gz'),
                idxList = idxlist,
                sampleNames = fnames)

```


### De-multiplexing the fastq

Experiments like MAPCap and RAMPAGE produce multiplexed fastq files with sample indicies and PCR barcodes attached to
the fastq sequence. The tool `demultiplexFASTQ` de-multiplexes the samples using the sample barcode, producing fastq files
corresponding to each sample. It also trims off these barcodes and attaches them in the header of the fastq files 
for further processing. Function returns a modified CapSet object that contains location of demultiplexed files
along with processing statistics.

```{r demultiplex, eval=TRUE}
# demultiplex fastq and trim the barcodes
dir.create("splitting")
cs <- demultiplexFASTQ(cs, max_mismatch = 1, outdir = "splitting", ncores = 10)
```

It takes about 6 min (340 sec) to trim and de-multiplex 1M PE reads into 12 sampels (12 pair of fastqs), using 1 thread. This can be done under 45 seconds if 10 threads are used.

Optionally, we can skip the above process and perform post-mapping de-multiplexing on the BAM files (see below).

### Mapping the fastqs

The demultiplexed fastqs can now be mapped using the `mapCaps` function. This function is a wrapper over the `subjunc`
function from `Rsubread` package. It additionally performes sorting and collects mapping statistics of the mapped files, 
stored in the modified `CapSet` object.

In order to run the function we first create a subread index of our genome.

```{r indexgenome, eval=FALSE}
dir.create("genome_index")
library(Rsubread)
buildindex(basename = "genome_index/dm6", reference = "/path/to/dm6/genome.fa")
```

We can now perform the mapping.

```{r mapcaps, eval=FALSE}
# provide location of a subread index file
subread_idx <- "genome_index/dm6"
# map fastq
cs <- mapCaps(cs, subread_idx, outdir = "mapping", nthreads = 20, logfile = "mapping/subread_mapping.log")
# you can save the CapSet object for later use
save(cs, file = "myCapSet.Rdata")
```

**Note:** The package Rsubread is not available for windows. Windows users would need to map their demultiplexed files using another tool.

**Note:** Since fastq de-multiplexing is an optinal step, we can perform mapping directly on the multiplexed files
and perform the de-multiplexing afterwards (see below).

### (optional) Post mapping de-multiplexing

Demultiplxeing can also be performed on the BAM files after mapping, using the `splitBAM_byIndex` and `splitBAM_byRepindex` functions.

```{r splitbam, eval=FALSE}
splitBAM_byIndex(bamFile, index_list, outfile_list, max_mismatch = 1, nthreads = 10)
```

### Filtering PCR duplicates

Experiments like MAPCap and RAMPAGE provide us a way to remove sequencing reads which are PCR duplicates from the 
mapped data. random UMIs are added to the read sequence for this purpose. In MAPCap, pre-designed random barcodes 
present in the oligos serve as the UMIs, while in RAMPAGE, the sequences used as RT-PCR primers are treated as 
pseudo-random barcodes. PCR duplicates are recognized by identifying reads that map to the same start and end site, 
and contain the same random UMI.

The function `filterDuplicates` removes these PCR duplicate sequences (keeping only one copy in these cases), and 
creates de-duplicated BAM files. It returns the modified `CapSet` object with de-duplication statistics.

```{r filterdups, eval=TRUE}
# load a previously saved CapSet object (or create new one)
cs <- exampleCSobject()
# filter PCR duplicates and save output in a new directory
dir.create("removedup")
cs <- filterDuplicates(cs, outdir = "removedup")
```

### Detection of TSS

ICETEA implements a new method of detection of transcription start sites, which is a adopted from recently described methods for peak calling and differential binding analysis methods. Genome is divided into 10 base-pair windows and the TSS are detected as the 
windows that show an X-fold enrichment over a local background of 2 kb. Multiple consicutively enriched windows are then merged to detect broad TSSs. The method works well with replicates.

This method is implemented in the function `detectTSS`, which returns a modified `CapSet` object with TSS detection statistics.

```{r getTSS, eval=TRUE}
# detect TSS
dir.create("tssCalling")
cs <- detectTSS(cs, groups = c("wt", "wt", "mut", "mut"), 
                 outfile_prefix = "tssCalling", restrictChr = "X", ncores = 1)
# export the detected TSS bed files
exportTSS(cs, merged = TRUE, outfile_prefix = "testTSS")
```


## Plotting and QC

The `sampleInfo` field of the CapSet object stores information about the read numbers kept at each step of processing, this 
information can be easily plotted using the function `plotReadStats`

We can either plot the number of reads at each step of processing, or the proportion of reads w.r.t total demultiplexed reads per sample. Stacked or separate barplots can be made for each category.

```{r plotstats, eval=TRUE}
# separate barchart for numbers
plotReadStats(cs, plotValue = "numbers", plotType = "dodge")
# stacked barchart for proportions
plotReadStats(cs, plotValue = "proportions", plotType = "stack" )
```

In case of well annotated genomes, one way to check the quality of TSS detection is to look at the fraction of detected
TSSs that fall close to an annotated TSS in the genome. The cumulative fraction can be plotted for each sample, which can 
be used to compare samples. This can be done using the function `plotTSSprecision`, which takes the *known* TSS annotations as 
a TxDB object.

```{r plotPrecision, eval=TRUE}
library("TxDb.Dmelanogaster.UCSC.dm6.ensGene")
seqlevelsStyle(TxDb.Dmelanogaster.UCSC.dm6.ensGene) <- "ENSEMBL"
# only analyse genes on chrX to make the analysis faster
seqlevels(TxDb.Dmelanogaster.UCSC.dm6.ensGene) <- "X"
transcripts <- transcripts(TxDb.Dmelanogaster.UCSC.dm6.ensGene)

# Plotting the precision using a pre computed set of TSS (.bed files) :
tssfile <- system.file("extdata", "testTSS_merged.bed", package = "icetea")
plotTSSprecision(reference = transcripts, detectedTSS = cs)
```



## Differential TSS expression analysis

For the experiments with two or more groups, ICETEA can also be used to perform differential TSS expression analysis for a group of samples. The requirements for differential TSS expression analysis is the same as that for differential expression analysis of RNA-Seq data. At least two or more biological replicates per group is required.

The functions `fitDiffTSS` and `detectDiffTSS` utilize edgeR to perform differential expression analysis.

```{r diffTSS, eval=FALSE}
csfit <- fitDiffTSS(cs, groups = rep(c("wt","mut"), each = 2), normalization = "windowTMM",
                     outplots = NULL, plotref = "embryo1")
save(csfit, file = "diffTSS_fit.Rdata")

detectDiffTSS(csfit, testGroup = "mut", controlGroup = "wt",
               tssFile = file.path(dir, "testTSS_merged.bed"), MAplot_fdr = 0.05)
```


### Using spike-In controls

For the differential TSS expression analysis, the function `fitDiffTSS` shown above utilize the [TMM method]()
for normalization of TSS counts. In some cases however, spike-in normalizations are preferred. ICETEA provides
a way to perform spike-in normalization during differential expression analysis.

Spike-In samples could be processed in the same way as the normal samples, using the `CapSet` object as described above.
Normalization factors can be obtained from the spike-in reads using `calcNormFactors` and provided to the `fitDiffTSS`
function during detection of differential TSS between samples.

```{r spikeNorm, eval=FALSE}
## get gene counts for spike-in RNA mapped to human genome
library("TxDb.Hsapiens.UCSC.hg38.knownGene")
normfacs <- calcNormFactors(cs_spike, features = genes(TxDb.Hsapiens.UCSC.hg38.knownGene))

csfit <- fitDiffTSS(cs, groups = rep(c("wt","mut"), each = 2), normalization = NULL, normFactors = normfacs,
                     outplots = NULL, plotref = "embryo1")
```


## Additional useful functions

### Sample information

Sample Information correspondng to the CapSet object can be obtained as a data.frame using the `sampleInfo` function. In case of underlying files being deleted or moved to another folder, we can reset the sample information.

```{r sampleinfo, eval=TRUE}
si <- sampleInfo(cs)
dir <- system.file("extdata/bam", package = "icetea")
si$mapped_file <- list.files(dir, pattern = ".bam$", full.names = TRUE)
sampleInfo(cs) <- si
```

### Getting the gene counts

Given the annotations, TSS counts for each gene can be summarized to gene counts. The following function sums up the TSS counts per gene from a given txdb object and returns gene counts.

```{r genecounts, eval=FALSE}
dm6trans <- transcriptsBy(TxDb.Dmelanogaster.UCSC.dm6.ensGene, "gene")
# get gene counts, counting reads around 500 bp of the TSS
gcounts <- getGeneCounts(cs, dm6trans)
```

### Annotating the TSS distribution

Detected TSS, which are exported as bed files, can be quickly annotated using the function `annotateTSS`. 
`annotateTSS` reports the numbers/proportions of detected TSS falling into different genomic features (provided
by a TxDb object). In order to break ties between overlapping features, we can provide a vector of feature names
in the decreasing order of preference.

```{r annotateTSS, eval = TRUE}
annotateTSS <- function(tssBED = tssfile,
                         txdb = TxDb.Dmelanogaster.UCSC.dm6.ensGene,
                         plotValue = "number",
                         outFile = NA)
```



